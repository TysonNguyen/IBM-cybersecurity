"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TreeUtils = exports.TreeViewItemLabelTypeEnum = exports.TreeMenuNodeIcon = void 0;
const lodash_1 = __importDefault(require("lodash"));
const __1 = require("..");
const constants_1 = require("../constants");
const utils_1 = require("../utils");
const vault_1 = require("../vault");
var TreeMenuNodeIcon;
(function (TreeMenuNodeIcon) {
    TreeMenuNodeIcon["bookOutlined"] = "bookOutlined";
    TreeMenuNodeIcon["numberOutlined"] = "numberOutlined";
    TreeMenuNodeIcon["plusOutlined"] = "plusOutlined";
})(TreeMenuNodeIcon = exports.TreeMenuNodeIcon || (exports.TreeMenuNodeIcon = {}));
var TreeViewItemLabelTypeEnum;
(function (TreeViewItemLabelTypeEnum) {
    TreeViewItemLabelTypeEnum["title"] = "title";
    TreeViewItemLabelTypeEnum["filename"] = "filename";
})(TreeViewItemLabelTypeEnum = exports.TreeViewItemLabelTypeEnum || (exports.TreeViewItemLabelTypeEnum = {}));
class TreeUtils {
    static generateTreeData(allNotes, domains) {
        // --- Calc
        const roots = domains
            .map((note) => {
            return TreeUtils.note2Tree({
                noteId: note.id,
                noteDict: allNotes,
            });
        })
            .filter((ent) => !lodash_1.default.isUndefined(ent));
        const child2parent = {};
        Object.entries(allNotes).forEach(([noteId, note]) => {
            child2parent[noteId] = note.parent;
        });
        return { roots, child2parent };
    }
    static note2Tree({ noteId, noteDict, }) {
        const note = noteDict[noteId];
        // return children of the curren tnote
        const getChildren = () => {
            if (fm.nav_exclude_children || fm.has_collection) {
                return [];
            }
            const { data } = this.sortNotesAtLevel({
                noteIds: note.children,
                noteDict,
                reverse: fm.sort_order === "reverse",
            });
            return data
                .map((noteId) => TreeUtils.note2Tree({
                noteId,
                noteDict,
            }))
                .filter(utils_1.isNotUndefined);
        };
        if (lodash_1.default.isUndefined(note)) {
            return undefined;
        }
        let icon = null;
        if (note.schema) {
            icon = TreeMenuNodeIcon.bookOutlined;
        }
        else if (note.fname.toLowerCase() === constants_1.TAGS_HIERARCHY_BASE) {
            icon = TreeMenuNodeIcon.numberOutlined;
        }
        else if (note.stub) {
            icon = TreeMenuNodeIcon.plusOutlined;
        }
        const fm = utils_1.PublishUtils.getPublishFM(note);
        return {
            key: note.id,
            title: note.title,
            icon,
            hasTitleNumberOutlined: note.fname.startsWith(constants_1.TAGS_HIERARCHY),
            vaultName: vault_1.VaultUtils.getName(note.vault),
            navExclude: fm.nav_exclude || false,
            children: getChildren(),
        };
    }
}
exports.TreeUtils = TreeUtils;
TreeUtils.getAllParents = ({ child2parent, noteId, }) => {
    const activeNoteIds = [noteId];
    let parent = child2parent[noteId];
    while (parent) {
        activeNoteIds.unshift(parent);
        parent = child2parent[parent];
    }
    return activeNoteIds;
};
TreeUtils.sortNotesAtLevel = ({ noteIds, noteDict, reverse, labelType, }) => {
    var _a;
    const unsafeNoteIds = [];
    const safeNoteIds = noteIds.filter((noteId) => {
        const props = lodash_1.default.get(noteDict, noteId);
        if (props === undefined) {
            unsafeNoteIds.push(noteId);
            return false;
        }
        else {
            return true;
        }
    });
    let error;
    if (unsafeNoteIds.length > 0) {
        error = new __1.DendronError({
            message: "Omitted sorting note ids not found in noteDict",
            payload: { omitted: unsafeNoteIds },
        });
    }
    const out = lodash_1.default.sortBy(safeNoteIds, 
    // Sort by nav order if set
    (noteId) => { var _a, _b; return (_b = (_a = noteDict[noteId]) === null || _a === void 0 ? void 0 : _a.custom) === null || _b === void 0 ? void 0 : _b.nav_order; }, 
    // Sort by label
    (noteId) => {
        var _a, _b, _c;
        if (labelType) {
            return labelType === TreeViewItemLabelTypeEnum.filename
                ? lodash_1.default.last((_a = noteDict[noteId]) === null || _a === void 0 ? void 0 : _a.fname.split("."))
                : (_b = noteDict[noteId]) === null || _b === void 0 ? void 0 : _b.title;
        }
        else {
            return (_c = noteDict[noteId]) === null || _c === void 0 ? void 0 : _c.title;
        }
    }, 
    // If titles are identical, sort by last updated date
    (noteId) => { var _a; return (_a = noteDict[noteId]) === null || _a === void 0 ? void 0 : _a.updated; });
    // bubble down tags hierarchy if nav_order is not set
    const maybeTagsHierarchy = out.find((noteId) => noteDict[noteId].fname === constants_1.TAGS_HIERARCHY_BASE);
    if (maybeTagsHierarchy &&
        ((_a = noteDict[maybeTagsHierarchy].custom) === null || _a === void 0 ? void 0 : _a.nav_order) === undefined) {
        const idx = out.indexOf(maybeTagsHierarchy);
        out.splice(idx, 1);
        out.push(maybeTagsHierarchy);
    }
    if (reverse) {
        return { data: lodash_1.default.reverse(out), error };
    }
    return { data: out, error };
};
//# sourceMappingURL=treeUtil.js.map