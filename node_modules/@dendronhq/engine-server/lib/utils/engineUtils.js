"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EngineUtils = exports.openPortFile = void 0;
const common_all_1 = require("@dendronhq/common-all");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
function openPortFile({ fpath }) {
    return lodash_1.default.toInteger(lodash_1.default.trim(fs_extra_1.default.readFileSync(fpath, { encoding: "utf8" })));
}
exports.openPortFile = openPortFile;
class EngineUtils {
    /**
     * Try to discover file for engine port. Will use following heuristic:
     * - look for file for workspace
     * - look for file for CLI
     * @param param0
     */
    static getPortFilePath(opts) {
        let portFilePath = EngineUtils.getPortFilePathForWorkspace(opts);
        if (fs_extra_1.default.existsSync(portFilePath)) {
            return { data: portFilePath };
        }
        portFilePath = EngineUtils.getPortFilePathForCLI(opts);
        if (fs_extra_1.default.existsSync(portFilePath)) {
            return { data: portFilePath };
        }
        return { error: common_all_1.ErrorFactory.create404Error({ url: portFilePath }) };
    }
    static getPortFilePathForTarget({ wsRoot, target, }) {
        const suffix = target === "cli" ? ".cli" : "";
        const portFile = path_1.default.join(wsRoot, common_all_1.CONSTANTS.DENDRON_SERVER_PORT) + suffix;
        return portFile;
    }
    static getPortFilePathForWorkspace({ wsRoot }) {
        return this.getPortFilePathForTarget({ wsRoot, target: "workspace" });
    }
    static getPortFilePathForCLI({ wsRoot }) {
        return this.getPortFilePathForTarget({ wsRoot, target: "cli" });
    }
    static getEnginePort(opts) {
        const resp = EngineUtils.getPortFilePath(opts);
        if (resp.error) {
            return resp;
        }
        const port = openPortFile({ fpath: resp.data });
        return { data: port };
    }
    static getEnginePortForCLI(opts) {
        const portFilePath = EngineUtils.getPortFilePathForCLI(opts);
        const port = openPortFile({ fpath: portFilePath });
        return port;
    }
    static getLocalEngineUrl({ port }) {
        return common_all_1.APIUtils.getLocalEndpoint(port);
    }
    static writeEnginePortForCLI(opts) {
        const portFilePath = EngineUtils.getPortFilePathForCLI(opts);
        fs_extra_1.default.writeFileSync(portFilePath, lodash_1.default.toString(opts.port), { encoding: "utf8" });
    }
    /**
     * NOTE: if the `note.body.length < maxNoteLength`, we will not add any links or anchors to the note
     * @param param0
     * @returns
     */
    static async refreshNoteLinksAndAnchors({ note, engine, }) {
        const maxNoteLength = common_all_1.ConfigUtils.getWorkspace(engine.config).maxNoteLength;
        if (note.body.length <
            (maxNoteLength || common_all_1.CONSTANTS.DENDRON_DEFAULT_MAX_NOTE_LENGTH)) {
            const links = await engine.getLinks({ note, type: "regular" });
            const anchors = await engine.getAnchors({
                note,
            });
            if (!anchors.data || !links.data)
                throw new common_all_1.DendronError({
                    message: "Failed to calculate note anchors",
                    payload: {
                        note: common_all_1.NoteUtils.toLogObj(note),
                        anchorsError: anchors.error,
                        linksError: links.error,
                    },
                });
            // update links for note
            note.links = links.data;
            note.anchors = anchors.data;
            const devConfig = common_all_1.ConfigUtils.getProp(engine.config, "dev");
            const linkCandidatesEnabled = devConfig === null || devConfig === void 0 ? void 0 : devConfig.enableLinkCandidates;
            if (linkCandidatesEnabled) {
                const linkCandidates = await engine.getLinks({
                    note,
                    type: "candidate",
                });
                if (!linkCandidates.data)
                    throw new common_all_1.DendronError({
                        message: "Failed to calculate link candidates",
                        payload: {
                            note: common_all_1.NoteUtils.toLogObj(note),
                            anchorsError: anchors.error,
                            linksError: links.error,
                        },
                    });
                note.links = note.links.concat(linkCandidates.data);
            }
            return note;
        }
        return note;
    }
}
exports.EngineUtils = EngineUtils;
//# sourceMappingURL=engineUtils.js.map