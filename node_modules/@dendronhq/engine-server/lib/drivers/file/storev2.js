"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileStorage = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const utils_1 = require("../../markdown/remark/utils");
const hooks_1 = require("../../topics/hooks");
const noteParser_1 = require("./noteParser");
const schemaParser_1 = require("./schemaParser");
const inMemoryNoteCache_1 = require("../../util/inMemoryNoteCache");
const cache_1 = require("../../cache");
class FileStorage {
    constructor(props) {
        const { vaults, wsRoot, config } = props.engine;
        const { logger } = props;
        this.wsRoot = wsRoot;
        this.configRoot = wsRoot;
        this.vaults = vaults;
        this.notes = {};
        this.noteFnames = {};
        this.schemas = {};
        this.links = [];
        this.anchors = [];
        this.logger = logger;
        const ctx = "FileStorageV2";
        this.logger.info({ ctx, wsRoot, vaults, level: this.logger.level });
        this.config = config;
        this.engine = props.engine;
    }
    async init() {
        var _a;
        let errors = [];
        try {
            const resp = await this.initSchema();
            if (common_all_1.ResponseUtil.hasError(resp)) {
                errors.push(FileStorage.createMalformedSchemaError(resp));
            }
            resp.data.map((ent) => {
                this.schemas[ent.root.id] = ent;
            });
            const { errors: initErrors } = await this.initNotes();
            errors = errors.concat(initErrors);
            // Backlink candidates have to be done after notes are initialized because it depends on the engine already having notes in it
            if ((_a = this.engine.config.dev) === null || _a === void 0 ? void 0 : _a.enableLinkCandidates) {
                const ctx = "_addLinkCandidates";
                const start = process.hrtime();
                // this mutates existing note objects so we don't need to reset the notes
                this._addLinkCandidates(lodash_1.default.values(this.notes));
                const duration = (0, common_server_1.getDurationMilliseconds)(start);
                this.logger.info({ ctx, duration });
            }
            const { notes, schemas } = this;
            let error = errors[0] || null;
            if (errors.length > 1) {
                error = new common_all_1.DendronCompositeError(errors);
            }
            return {
                data: {
                    notes,
                    schemas,
                    wsRoot: this.wsRoot,
                    config: this.config,
                    vaults: this.vaults,
                },
                error,
            };
        }
        catch (err) {
            this.logger.error(err);
            throw err;
        }
    }
    static createMalformedSchemaError(resp) {
        let fileName = common_all_1.USER_MESSAGES.UNKNOWN;
        try {
            if (resp.error && resp.error.payload) {
                fileName = JSON.parse(JSON.parse(resp.error.payload)[0].payload).fpath;
            }
        }
        catch (parseErr) {
            fileName = common_all_1.USER_MESSAGES.UNKNOWN;
        }
        let fullPath;
        try {
            if (resp.error && resp.error.payload) {
                fullPath = JSON.parse(JSON.parse(resp.error.payload)[0].payload).fullPath;
            }
        }
        catch (parseErr) {
            fullPath = undefined;
        }
        let reason = common_all_1.USER_MESSAGES.UNKNOWN;
        try {
            if (resp.error && resp.error.payload) {
                reason = JSON.parse(JSON.parse(resp.error.payload)[0].payload).message;
            }
        }
        catch (parseErr) {
            reason = common_all_1.USER_MESSAGES.UNKNOWN;
        }
        return new common_all_1.DendronError({
            message: `Schema '${fileName}' is malformed. Reason: ${reason}`,
            severity: common_all_1.ERROR_SEVERITY.MINOR,
            payload: { schema: resp.error, fullPath },
        });
    }
    /**
     * See {@link DStore.getNote}
     */
    async getNote(id) {
        const maybeNote = this.notes[id];
        if (maybeNote) {
            return lodash_1.default.cloneDeep(maybeNote);
        }
        else {
            return undefined;
        }
    }
    /**
     * See {@link DStore.findNotes}
     */
    async findNotes(opts) {
        const { fname, vault } = opts;
        if (fname) {
            return lodash_1.default.cloneDeep(common_all_1.NoteDictsUtils.findByFname(fname, { notesById: this.notes, notesByFname: this.noteFnames }, vault));
        }
        else if (vault) {
            return lodash_1.default.cloneDeep(lodash_1.default.values(this.notes).filter((note) => common_all_1.VaultUtils.isEqualV2(note.vault, vault)));
        }
        else {
            return [];
        }
    }
    /**
     *
     * @param id id of note to be deleted
     * @param opts EngineDeleteOptsV2 the flag `replaceWithNewStub` is used
     *             for a specific case where this method is called from
     *             `renameNote`. TODO: remove this flag so that this is handled
     *             automatically.
     * @returns
     */
    async deleteNote(id, opts) {
        const ctx = "deleteNote";
        if (id === "root") {
            throw new common_all_1.DendronError({
                message: "",
                status: common_all_1.ERROR_STATUS.CANT_DELETE_ROOT,
            });
        }
        const noteToDelete = this.notes[id];
        this.logger.info({ ctx, noteToDelete, opts, id });
        if (lodash_1.default.isUndefined(noteToDelete))
            throw new common_all_1.DendronError({
                message: `Unable to find node ${id}`,
                severity: common_all_1.ERROR_SEVERITY.FATAL,
                payload: ctx,
            });
        const ext = ".md";
        const vault = noteToDelete.vault;
        const vpath = (0, common_server_1.vault2Path)({ vault, wsRoot: this.wsRoot });
        const fpath = path_1.default.join(vpath, noteToDelete.fname + ext);
        let out = [];
        const noteAsLog = common_all_1.NoteUtils.toLogObj(noteToDelete);
        // remove from fs
        if (!(opts === null || opts === void 0 ? void 0 : opts.metaOnly)) {
            this.logger.info({ ctx, noteAsLog, msg: "removing from disk", fpath });
            await fs_extra_1.default.unlink(fpath);
        }
        // if have children, keep this node around as a stub
        if (!lodash_1.default.isEmpty(noteToDelete.children)) {
            if (!(opts === null || opts === void 0 ? void 0 : opts.replaceWithNewStub)) {
                this.logger.info({ ctx, noteAsLog, msg: "keep as stub" });
                const prevNote = { ...noteToDelete };
                noteToDelete.stub = true;
                this.updateNote(noteToDelete);
                out.push({ note: noteToDelete, status: "update", prevNote });
            }
            else {
                // the delete operation originated from rename.
                // since _noteToDelete_ in this case is renamed and
                // moved to another location, simply adding stub: true
                // will not work.
                // we need a fresh stub note that will fill in the old note's place.
                const replacingStub = common_all_1.NoteUtils.create({
                    // the replacing stub should not keep the old note's body and link.
                    // otherwise, it will be captured while processing links and will
                    // fail because this note is not actually in the file system.
                    ...lodash_1.default.omit(noteToDelete, ["id", "links", "body"]),
                    stub: true,
                });
                this.logger.info({ ctx, noteAsLog, msg: "delete from parent" });
                if (!noteToDelete.parent) {
                    throw common_all_1.DendronError.createFromStatus({
                        status: common_all_1.ERROR_STATUS.NO_PARENT_FOR_NOTE,
                    });
                }
                const parentNote = this.notes[noteToDelete.parent];
                if (parentNote) {
                    const parentNotePrev = { ...parentNote };
                    parentNote.children = lodash_1.default.reject(parentNote.children, (ent) => ent === noteToDelete.id);
                    out.push({
                        note: parentNote,
                        status: "update",
                        prevNote: parentNotePrev,
                    });
                }
                else {
                    this.logger.error({
                        ctx,
                        noteToDelete,
                        message: "Parent note missing from state",
                    });
                }
                common_all_1.NoteDictsUtils.delete(noteToDelete, {
                    notesById: this.notes,
                    notesByFname: this.noteFnames,
                });
                const changed = await this.writeNote(replacingStub, { newNode: true });
                out.push({ note: noteToDelete, status: "delete" });
                if (changed.data) {
                    out = out.concat(changed.data);
                }
            }
        }
        else {
            // no children, delete reference from parent
            this.logger.info({ ctx, noteAsLog, msg: "delete from parent" });
            if (!noteToDelete.parent) {
                throw common_all_1.DendronError.createFromStatus({
                    status: common_all_1.ERROR_STATUS.NO_PARENT_FOR_NOTE,
                });
            }
            // delete from note dictionary
            common_all_1.NoteDictsUtils.delete(noteToDelete, {
                notesById: this.notes,
                notesByFname: this.noteFnames,
            });
            // remove from parent
            const resps = [];
            let parentNote = this.notes[noteToDelete.parent];
            if (parentNote) {
                const parentNotePrev = { ...parentNote };
                parentNote.children = lodash_1.default.reject(parentNote.children, (ent) => ent === noteToDelete.id);
                // if parent note is not a stub, update it
                if (!parentNote.stub) {
                    out.push({
                        note: parentNote,
                        status: "update",
                        prevNote: parentNotePrev,
                    });
                }
                // check all stubs
                while (parentNote.stub && !(opts === null || opts === void 0 ? void 0 : opts.noDeleteParentStub)) {
                    const newParent = parentNote.parent;
                    const resp = this.deleteNote(parentNote.id, {
                        metaOnly: true,
                        noDeleteParentStub: true,
                    });
                    resps.push(resp);
                    if (newParent) {
                        parentNote = this.notes[newParent];
                    }
                    else {
                        (0, common_all_1.assert)(false, "illegal state in note delete");
                    }
                }
            }
            else {
                this.logger.error({
                    ctx,
                    noteToDelete,
                    message: "Parent note missing from state",
                });
            }
            out.push({ note: noteToDelete, status: "delete" });
            for (const resp of await Promise.all(resps)) {
                out = out.concat(resp);
            }
        }
        return out;
    }
    async deleteSchema(id, opts) {
        const ctx = "deleteSchema";
        this.logger.info({ ctx, msg: "enter", id });
        if (id === "root") {
            throw common_all_1.DendronError.createFromStatus({
                status: common_all_1.ERROR_STATUS.CANT_DELETE_ROOT,
            });
        }
        const schemaToDelete = this.schemas[id];
        const ext = ".schema.yml";
        const vault = schemaToDelete.vault;
        const vpath = (0, common_server_1.vault2Path)({ vault, wsRoot: this.wsRoot });
        const fpath = path_1.default.join(vpath, schemaToDelete.fname + ext);
        if (!(opts === null || opts === void 0 ? void 0 : opts.metaOnly)) {
            fs_extra_1.default.unlinkSync(fpath);
        }
        delete this.schemas[id];
        return this.init();
    }
    async initSchema() {
        const ctx = "initSchema";
        this.logger.info({ ctx, msg: "enter" });
        const out = await Promise.all(this.vaults.map(async (vault) => {
            return this._initSchema(vault);
        }));
        const _out = lodash_1.default.reduce(out, (ent, acc) => {
            acc.data = acc.data.concat(ent.data);
            acc.errors = acc.errors.concat(ent.errors);
            return acc;
        }, { data: [], errors: [] });
        const { data, errors } = _out;
        const result = {
            data,
            error: lodash_1.default.isEmpty(errors)
                ? null
                : new common_all_1.DendronError({ message: "multiple errors", payload: errors }),
        };
        return result;
    }
    async _initSchema(vault) {
        const ctx = "initSchema";
        this.logger.info({ ctx, msg: "enter" });
        const vpath = (0, common_server_1.vault2Path)({ vault, wsRoot: this.wsRoot });
        const out = await (0, common_server_1.getAllFiles)({
            root: vpath,
            include: ["*.schema.yml"],
        });
        if (out.error || !out.data) {
            return {
                data: [],
                errors: [
                    new common_all_1.DendronError({
                        message: `Unable to get schemas for vault ${common_all_1.VaultUtils.getName(vault)}`,
                        severity: common_all_1.ERROR_SEVERITY.MINOR,
                        payload: out.error,
                    }),
                ],
            };
        }
        const schemaFiles = out.data.map((entry) => entry.toString());
        this.logger.info({ ctx, schemaFiles });
        if (lodash_1.default.isEmpty(schemaFiles)) {
            throw common_all_1.DendronError.createFromStatus({
                status: common_all_1.ERROR_STATUS.NO_SCHEMA_FOUND,
                message: JSON.stringify(vault),
            });
        }
        const { schemas, errors } = await new schemaParser_1.SchemaParser({
            wsRoot: this.wsRoot,
            logger: this.logger,
        }).parse(schemaFiles, vault);
        return {
            data: schemas,
            errors: lodash_1.default.isNull(errors) ? [] : errors,
        };
    }
    async initNotes() {
        const ctx = "initNotes";
        this.logger.info({ ctx, msg: "enter" });
        let notesWithLinks = [];
        let errors = [];
        const start = process.hrtime();
        const out = await Promise.all(this.vaults.map(async (vault) => {
            const { notesById, cacheUpdates, errors: initErrors, } = await this._initNotes(vault);
            errors = errors.concat(initErrors);
            notesWithLinks = notesWithLinks.concat(lodash_1.default.filter(notesById, (n) => !lodash_1.default.isEmpty(n.links)));
            this.logger.info({
                ctx,
                vault,
                numEntries: lodash_1.default.size(notesById),
                numCacheUpdates: lodash_1.default.size(cacheUpdates),
            });
            return notesById;
        }));
        this.notes = Object.assign({}, ...out);
        this.noteFnames = common_all_1.NoteFnameDictUtils.createNotePropsByFnameDict(this.notes);
        const allNotes = lodash_1.default.values(this.notes);
        if (lodash_1.default.size(this.notes) === 0) {
            errors.push(new common_all_1.DendronError({
                message: "No vaults initialized!",
                severity: common_all_1.ERROR_SEVERITY.FATAL,
            }));
        }
        this._addBacklinks({ notesWithLinks, allNotes });
        const duration = (0, common_server_1.getDurationMilliseconds)(start);
        this.logger.info({ ctx, msg: `time to init notes: "${duration}" ms` });
        return { errors };
    }
    /** Adds backlinks mutating 'allNotes' argument in place. */
    _addBacklinks({ notesWithLinks, allNotes, }) {
        const ctx = "_addBacklinks:ext";
        const start = process.hrtime();
        this._addBacklinksImpl(allNotes, notesWithLinks);
        const duration = (0, common_server_1.getDurationMilliseconds)(start);
        this.logger.info({ ctx, duration });
    }
    _addBacklinksImpl(allNotes, notesWithLinks) {
        const noteCache = new inMemoryNoteCache_1.InMemoryNoteCache(allNotes);
        notesWithLinks.forEach((noteFrom) => {
            try {
                noteFrom.links.forEach((link) => {
                    var _a;
                    const fname = (_a = link.to) === null || _a === void 0 ? void 0 : _a.fname;
                    // Note referencing itself does not count as backlink
                    if (fname && fname !== noteFrom.fname) {
                        const notes = noteCache.getNotesByFileNameIgnoreCase(fname);
                        notes.forEach((noteTo) => {
                            common_all_1.NoteUtils.addBacklink({
                                from: noteFrom,
                                to: noteTo,
                                link,
                            });
                        });
                    }
                });
            }
            catch (err) {
                const error = (0, common_all_1.error2PlainObject)(err);
                this.logger.error({ error, noteFrom, message: "issue with backlinks" });
            }
        });
    }
    _addLinkCandidates(allNotes) {
        return lodash_1.default.map(allNotes, (noteFrom) => {
            try {
                const maxNoteLength = common_all_1.ConfigUtils.getWorkspace(this.config).maxNoteLength;
                if (noteFrom.body.length <
                    (maxNoteLength || common_all_1.CONSTANTS.DENDRON_DEFAULT_MAX_NOTE_LENGTH)) {
                    const linkCandidates = utils_1.LinkUtils.findLinkCandidates({
                        note: noteFrom,
                        engine: this.engine,
                    });
                    noteFrom.links = noteFrom.links.concat(linkCandidates);
                }
            }
            catch (err) {
                const error = (0, common_all_1.error2PlainObject)(err);
                this.logger.error({
                    error,
                    noteFrom,
                    message: "issue with link candidates",
                });
                return;
            }
        });
    }
    async _initNotes(vault) {
        const ctx = "initNotes";
        let errors = [];
        this.logger.info({ ctx, msg: "enter" });
        const wsRoot = this.wsRoot;
        const vpath = (0, common_server_1.vault2Path)({ vault, wsRoot });
        const out = await (0, common_server_1.getAllFiles)({
            root: vpath,
            include: ["*.md"],
        });
        if (out.error) {
            // Keep initializing other vaults
            errors.push(new common_all_1.DendronError({
                message: `Unable to read notes for vault ${common_all_1.VaultUtils.getName(vault)}`,
                severity: common_all_1.ERROR_SEVERITY.MINOR,
                payload: out.error,
            }));
        }
        const cachePath = path_1.default.join(vpath, common_all_1.CONSTANTS.DENDRON_CACHE_FILE);
        const notesCache = new cache_1.NotesFileSystemCache({
            cachePath,
            noCaching: this.engine.config.noCaching,
            logger: this.logger,
        });
        if (!out.data) {
            return {
                cacheUpdates: {},
                errors,
                notesById: {},
            };
        }
        const noteFiles = out.data;
        const maxNoteLength = common_all_1.ConfigUtils.getWorkspace(this.config).maxNoteLength;
        const { notesById, cacheUpdates, errors: parseErrors, } = await new noteParser_1.NoteParser({
            store: this,
            cache: notesCache,
            engine: this.engine,
            logger: this.logger,
            maxNoteLength,
        }).parseFiles(noteFiles, vault);
        errors = errors.concat(parseErrors);
        this.logger.info({ ctx, msg: "parseNotes:fin" });
        return { notesById, cacheUpdates, errors };
    }
    async bulkWriteNotes(opts) {
        this.logger.info({ ctx: "bulkWriteNotes", msg: "enter" });
        if (opts.skipMetadata) {
            const noteDicts = {
                notesById: this.notes,
                notesByFname: this.noteFnames,
            };
            await Promise.all(opts.notes.map((note) => {
                common_all_1.NoteDictsUtils.add(note, noteDicts);
                return (0, common_server_1.note2File)({
                    note,
                    vault: note.vault,
                    wsRoot: this.wsRoot,
                });
            }));
            const notesChanged = opts.notes.map((n) => {
                return { note: n, status: "create" };
            });
            return {
                error: null,
                data: notesChanged,
            };
        }
        const writeResponses = await Promise.all(opts.notes.flatMap(async (note) => {
            return this.writeNote(note, opts.opts);
        }));
        const errors = writeResponses
            .flatMap((response) => response.error)
            .filter(common_all_1.isNotNull);
        return {
            error: errors.length > 0 ? new common_all_1.DendronCompositeError(errors) : null,
            data: writeResponses
                .flatMap((response) => response.data)
                .filter(common_all_1.isNotUndefined),
        };
    }
    referenceRangeParts(anchorHeader) {
        if (!anchorHeader || anchorHeader.indexOf(":") === -1)
            return [];
        let [start, end] = anchorHeader.split(":");
        start = start.replace(/^#*/, "");
        end = end.replace(/^#*/, "");
        return [start, end];
    }
    /**
     * Update the links inside this note that need to be updated for the rename from `oldLoc` to `newLoc`
     * Will update the note in place
     */
    async processNoteChangedByRename({ note, oldLoc, newLoc, }) {
        const ctx = "store:processNoteChangedByRename";
        const prevNote = { ...note };
        const vault = note.vault;
        const vaultPath = (0, common_server_1.vault2Path)({ vault, wsRoot: this.wsRoot });
        // read note in case its changed
        const resp = (0, common_server_1.file2Note)(path_1.default.join(vaultPath, note.fname + ".md"), vault);
        if (common_all_1.ErrorUtils.isErrorResp(resp)) {
            // couldn't read note. log it and return.
            this.logger.error({ ctx, error: (0, common_all_1.stringifyError)(resp.error) });
            return;
        }
        const _n = resp.data;
        const foundLinks = utils_1.LinkUtils.findLinks({
            note: _n,
            engine: this.engine,
            filter: { loc: oldLoc },
        });
        // important to order by position since we replace links and this affects
        // subsequent links
        let allLinks = lodash_1.default.orderBy(foundLinks, (link) => {
            var _a;
            return (_a = link.position) === null || _a === void 0 ? void 0 : _a.start.offset;
        }, "desc");
        // perform header updates as needed
        if (oldLoc.fname.toLowerCase() === newLoc.fname.toLowerCase() &&
            // TODO: we don't have a spec on vault name but to be consistent, we should also lowercase
            oldLoc.vaultName === newLoc.vaultName &&
            oldLoc.anchorHeader &&
            newLoc.anchorHeader) {
            // Renaming the header, only update links that link to the old header
            allLinks = lodash_1.default.filter(allLinks, (link) => {
                var _a, _b;
                // This is a wikilink to this header
                if (((_a = link.to) === null || _a === void 0 ? void 0 : _a.anchorHeader) === oldLoc.anchorHeader)
                    return true;
                // Or this is a range reference, and one part of the range includes this header
                return (link.type === "ref" &&
                    (0, common_all_1.isNotUndefined)(oldLoc.anchorHeader) &&
                    this.referenceRangeParts((_b = link.to) === null || _b === void 0 ? void 0 : _b.anchorHeader).includes(oldLoc.anchorHeader));
            });
        }
        // filter all links for following criteria:
        // - only modify links that have same _to_ vault name
        // - explicitly same: has vault prefix
        // - implicitly same: to.vaultName is undefined, but link is in a note that's in the vault.
        allLinks = allLinks.filter((link) => {
            var _a, _b;
            const oldLocVaultName = oldLoc.vaultName;
            const explicitlySameVault = ((_a = link.to) === null || _a === void 0 ? void 0 : _a.vaultName) === oldLocVaultName;
            const oldLocVault = common_all_1.VaultUtils.getVaultByName({
                vaults: this.vaults,
                vname: oldLocVaultName,
            });
            const implicitlySameVault = lodash_1.default.isUndefined((_b = link.to) === null || _b === void 0 ? void 0 : _b.vaultName) && lodash_1.default.isEqual(note.vault, oldLocVault);
            return explicitlySameVault || implicitlySameVault;
        });
        // perform link substitution
        // TODO: this should be extracted into a re-usable utility since it comes up quite a lot
        const noteMod = lodash_1.default.reduce(allLinks, (note, link) => {
            var _a;
            const oldLink = utils_1.LinkUtils.dlink2DNoteLink(link);
            // current implementation adds alias for all notes
            // check if old note has alias thats different from its fname
            let alias;
            if (oldLink.from.alias && oldLink.from.alias !== oldLink.from.fname) {
                alias = oldLink.from.alias;
                // Update the alias if it was using the default alias.
                if (((_a = oldLoc.alias) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) ===
                    oldLink.from.alias.toLocaleLowerCase() &&
                    newLoc.alias) {
                    alias = newLoc.alias;
                }
            }
            // for hashtag links, we'll have to regenerate the alias
            if (newLoc.fname.startsWith(common_all_1.TAGS_HIERARCHY)) {
                const fnameWithoutTag = newLoc.fname.slice(common_all_1.TAGS_HIERARCHY.length);
                // Frontmatter tags don't have the hashtag
                if (link.type !== "frontmatterTag")
                    alias = `#${fnameWithoutTag}`;
                else
                    alias = fnameWithoutTag;
            }
            else if (oldLink.from.fname.startsWith(common_all_1.TAGS_HIERARCHY)) {
                // If this used to be a hashtag but no longer is, the alias is like `#foo.bar` and no longer makes sense.
                // And if this used to be a frontmatter tag, the alias being undefined will force it to be removed because a frontmatter tag can't point to something outside of tags hierarchy.
                alias = undefined;
            }
            // for user tag links, we'll have to regenerate the alias
            if (newLoc.fname.startsWith(common_all_1.USERS_HIERARCHY)) {
                const fnameWithoutTag = newLoc.fname.slice(common_all_1.USERS_HIERARCHY.length);
                alias = `@${fnameWithoutTag}`;
            }
            else if (oldLink.from.fname.startsWith(common_all_1.USERS_HIERARCHY)) {
                // If this used to be a user tag but no longer is, the alias is like `@foo.bar` and no longer makes sense.
                alias = undefined;
            }
            // Correctly handle header renames in references with range based references
            if (oldLoc.anchorHeader &&
                link.type === "ref" &&
                (0, common_all_1.isNotUndefined)(oldLink.from.anchorHeader) &&
                oldLink.from.anchorHeader.indexOf(":") > -1 &&
                (0, common_all_1.isNotUndefined)(newLoc.anchorHeader) &&
                newLoc.anchorHeader.indexOf(":") === -1) {
                // This is a reference, old anchor had a ":" in it, a new anchor header is provided and does not have ":" in it.
                // For example, `![[foo#start:#end]]` to `![[foo#something]]`. In this case, `something` is actually supposed to replace only one part of the range.
                // Find the part that matches the old header, and replace just that with the new one.
                let [start, end] = this.referenceRangeParts(oldLink.from.anchorHeader);
                if (start === oldLoc.anchorHeader)
                    start = newLoc.anchorHeader;
                if (end === oldLoc.anchorHeader)
                    end = newLoc.anchorHeader;
                newLoc.anchorHeader = `${start}:#${end}`;
            }
            const newBody = utils_1.LinkUtils.updateLink({
                note,
                oldLink,
                newLink: {
                    ...oldLink,
                    from: {
                        ...newLoc,
                        anchorHeader: newLoc.anchorHeader || oldLink.from.anchorHeader,
                        alias,
                    },
                },
            });
            _n.body = newBody;
            return _n;
        }, _n);
        // replace note body if needed
        const shouldChange = !(note.body === noteMod.body && note.tags === noteMod.tags);
        if (shouldChange) {
            note.body = noteMod.body;
            note.tags = noteMod.tags;
            return {
                note,
                prevNote,
                status: "update",
            };
        }
        return;
    }
    async renameNote(opts) {
        const ctx = "Store:renameNote";
        const { oldLoc, newLoc } = opts;
        const { wsRoot } = this;
        this.logger.info({ ctx, msg: "enter", opts });
        const oldVault = common_all_1.VaultUtils.getVaultByName({
            vaults: this.engine.vaults,
            vname: oldLoc.vaultName,
        });
        if (!oldVault) {
            throw new common_all_1.DendronError({ message: "vault not set for loation" });
        }
        const vpath = (0, common_server_1.vault2Path)({ wsRoot, vault: oldVault });
        const oldLocPath = path_1.default.join(vpath, oldLoc.fname + ".md");
        // TODO: Move this business logic to engine so we can update metadata
        // read from disk since contents might have changed
        const resp = (0, common_server_1.file2Note)(oldLocPath, oldVault);
        if (common_all_1.ErrorUtils.isErrorResp(resp)) {
            throw new common_all_1.DendronError({ message: "file not found" });
        }
        const noteRaw = resp.data;
        const oldNote = common_all_1.NoteUtils.hydrate({
            noteRaw,
            noteHydrated: this.notes[noteRaw.id],
        });
        const newNoteTitle = common_all_1.NoteUtils.isDefaultTitle(oldNote)
            ? common_all_1.NoteUtils.genTitle(newLoc.fname)
            : oldNote.title;
        // If the rename operation is changing the title and the caller did not tell us to use a special alias, calculate the alias change.
        // The aliases of links to this note will only change if they match the old note's title.
        if (newNoteTitle !== oldNote.title && !oldLoc.alias && !newLoc.alias) {
            oldLoc.alias = oldNote.title;
            newLoc.alias = newNoteTitle;
        }
        let notesChangedEntries = [];
        const notesWithLinkTo = common_all_1.NoteUtils.getNotesWithLinkTo({
            note: oldNote,
            notes: this.notes,
        });
        this.logger.info({
            ctx,
            msg: "notesWithLinkTo:gather",
            notes: notesWithLinkTo.map((n) => common_all_1.NoteUtils.toLogObj(n)),
        });
        // update note body of all notes that have changed
        await (0, common_all_1.asyncLoopOneAtATime)(notesWithLinkTo, async (n) => {
            const out = await this.processNoteChangedByRename({
                note: n,
                oldLoc,
                newLoc,
            });
            if (out !== undefined) {
                notesChangedEntries.push(out);
            }
        });
        /**
         * If the event source is not engine(ie: vscode rename context menu), we do not want to
         * delete the original files. We just update the references on onWillRenameFiles and return.
         */
        if (!lodash_1.default.isUndefined(opts.isEventSourceEngine)) {
            return (await this.bulkWriteNotes({
                notes: notesChangedEntries.map((ent) => ent.note),
                opts: { updateExisting: true },
            })).data;
        }
        const newNote = {
            ...oldNote,
            fname: newLoc.fname,
            vault: common_all_1.VaultUtils.getVaultByName({
                vaults: this.vaults,
                vname: newLoc.vaultName,
            }),
            title: newNoteTitle,
            // when renaming, we are moving a note into a completely different hierarchy. ^pojmz0g80gds
            // we are not concerned with the children it has, so the new note
            // shouldn't inherit the old note's children.
            children: [],
        };
        // NOTE: order matters. need to delete old note, otherwise can't write new note
        this.logger.info({
            ctx,
            msg: "deleteNote:meta:pre",
            note: common_all_1.NoteUtils.toLogObj(oldNote),
        });
        let deleteOldFile = false;
        let changedFromDelete = [];
        let changeFromWrite;
        if (oldNote.fname.toLowerCase() === newNote.fname.toLowerCase() &&
            common_all_1.VaultUtils.isEqual(oldNote.vault, newNote.vault, wsRoot)) {
            // The file is being renamed to itself. We do this to rename a header.
            this.logger.info({ ctx, msg: "Renaming the file to same name" });
            // we remove the children [[here|../packages/engine-server/src/drivers/file/storev2.ts#^pojmz0g80gds]],
            // but we don't want that in this case. we need to add the old note's children back in
            newNote.children = oldNote.children;
            const out = await this.writeNote(newNote, { updateExisting: true });
            changeFromWrite = out.data;
        }
        else {
            // The file is being renamed to a new file.
            this.logger.info({ ctx, msg: "Renaming the file to a new name" });
            try {
                changedFromDelete = await this.deleteNote(oldNote.id, {
                    metaOnly: true,
                    replaceWithNewStub: true,
                });
            }
            catch (err) {
                throw new common_all_1.DendronError({
                    message: `Unable to delete note "${oldNote.fname}" in vault "${common_all_1.VaultUtils.getName(oldNote.vault)}".` +
                        ` Check that this note exists, and make sure it has a frontmatter with an id.`,
                    severity: common_all_1.ERROR_SEVERITY.FATAL,
                    payload: err,
                });
            }
            deleteOldFile = true;
            this.logger.info({
                ctx,
                msg: "writeNewNote:pre",
                note: common_all_1.NoteUtils.toLogObj(newNote),
            });
            const out = await this.writeNote(newNote, { newNode: true });
            changeFromWrite = out.data;
        }
        this.logger.info({ ctx, msg: "updateAllNotes:pre" });
        // update all new notes
        await this.bulkWriteNotes({
            notes: notesChangedEntries.map((ent) => ent.note),
            opts: { updateExisting: true },
        });
        if (deleteOldFile)
            fs_extra_1.default.removeSync(oldLocPath);
        // create needs to be very last element added
        notesChangedEntries = changedFromDelete.concat(notesChangedEntries);
        if (changeFromWrite) {
            notesChangedEntries = notesChangedEntries.concat(changeFromWrite);
        }
        this.logger.info({ ctx, msg: "exit", opts, out: notesChangedEntries });
        return notesChangedEntries;
    }
    /**
     * Update a note.
     *
     * If {@link newNode} is set, set the {@link NoteProps["parent"]} property and create stubs as necessary
     *
     * @param note
     * @param opts
     * @returns
     */
    async updateNote(note, opts) {
        const ctx = "updateNote";
        this.logger.debug({ ctx, note: common_all_1.NoteUtils.toLogObj(note), msg: "enter" });
        const changes = [];
        try {
            const noteDicts = {
                notesById: this.notes,
                notesByFname: this.noteFnames,
            };
            if (opts === null || opts === void 0 ? void 0 : opts.newNode) {
                const changesToParents = common_all_1.NoteUtils.addOrUpdateParents({
                    note,
                    noteDicts,
                    createStubs: true,
                    wsRoot: this.wsRoot,
                });
                changesToParents.forEach((changedEntry) => {
                    common_all_1.NoteDictsUtils.add(changedEntry.note, noteDicts);
                    changes.push(changedEntry);
                });
                changes.push({
                    note,
                    status: "create",
                });
            }
            else {
                const prevNote = noteDicts.notesById[note.id];
                changes.push({
                    prevNote,
                    note,
                    status: "update",
                });
            }
            this.logger.debug({ ctx, note: common_all_1.NoteUtils.toLogObj(note) });
            common_all_1.NoteDictsUtils.add(note, noteDicts);
        }
        catch (error) {
            return { error };
        }
        return { data: changes, error: null };
    }
    async updateSchema(schemaModule) {
        this.schemas[schemaModule.root.id] = schemaModule;
        // const vaultDir = this.vaults[0];
        // await schemaModuleProps2File(schemaModule, vaultDir, schemaModule.fname);
        // TODO: update notes
    }
    /**
     * Write a new note. Also take care of updating logic of parents and children if new note replaces an existing note
     * @param param0
     * @returns - Changed Entries
     */
    async _writeNewNote({ note, existingNote, opts, }) {
        const ctx = "_writeNewNote";
        this.logger.info({
            ctx,
            msg: "enter",
            note: common_all_1.NoteUtils.toLogObj(note),
        });
        let changed = [];
        const noteDicts = {
            notesById: this.notes,
            notesByFname: this.noteFnames,
        };
        // in this case, we are deleting the old note and writing a new note in its place with the same hierarchy
        // the parent of this note needs to have the old note removed (because the id is now different)
        // the new note needs to have the old note's children
        if (existingNote) {
            // make sure existing note actually has a parent.
            if (!existingNote.parent) {
                // TODO: We should be able to handle rewriting of root. This happens
                // with certain operations such as Doctor FixFrontmatter
                throw new common_all_1.DendronError({
                    message: `no parent found for ${note.fname}`,
                });
            }
            // save the state of the parent to later record changed entry.
            const parent = this.notes[existingNote.parent];
            const prevParentState = { ...parent };
            // delete the existing note.
            common_all_1.NoteDictsUtils.delete(existingNote, noteDicts);
            // first, update existing note's parent
            // so that it doesn't hold the deleted existing note's id as children
            common_all_1.NoteUtils.deleteChildFromParent({
                childToDelete: existingNote,
                notes: this.notes,
            });
            // then update parent note of existing note
            // so that the newly created note is a child
            common_all_1.DNodeUtils.addChild(parent, note);
            // add an entry for the updated parent if there was a change
            changed.push({
                prevNote: prevParentState,
                note: parent,
                status: "update",
            });
            // now move existing note's orphaned children to new note
            existingNote.children.forEach((child) => {
                const childNote = this.notes[child];
                const prevChildNoteState = { ...childNote };
                common_all_1.DNodeUtils.addChild(note, childNote);
                // add one entry for each child updated
                changed.push({
                    prevNote: prevChildNoteState,
                    note: childNote,
                    status: "update",
                });
            });
        }
        // check if we need to add parents
        // eg. if user created `baz.one.two` and neither `baz` or `baz.one` exist, then they need to be created
        // this is the default behavior
        // only do this if we aren't writing to existing note. we never hit this case in that situation.
        if (!(opts === null || opts === void 0 ? void 0 : opts.noAddParent) && !existingNote) {
            const out = common_all_1.NoteUtils.addOrUpdateParents({
                note,
                noteDicts,
                createStubs: true,
                wsRoot: this.wsRoot,
            });
            // add one entry for each parent updated
            changed = changed.concat(out);
        }
        this.logger.info({
            ctx,
            msg: "exit",
            changed: changed.map((n) => common_all_1.NoteUtils.toLogObj(n.note)),
        });
        return changed;
    }
    async writeNote(note, opts) {
        const ctx = `FileStore:writeNote:${note.fname}`;
        let changedEntries = [];
        let error = null;
        this.logger.info({
            ctx,
            msg: "enter",
            opts,
            note: common_all_1.NoteUtils.toLogObj(note),
        });
        // check if note might already exist
        const maybeNote = common_all_1.NoteDictsUtils.findByFname(note.fname, { notesById: this.notes, notesByFname: this.noteFnames }, note.vault)[0];
        this.logger.info({
            ctx,
            msg: "check:existing",
            maybeNoteId: lodash_1.default.pick(maybeNote || {}, ["id", "stub"]),
        });
        // don't count as delete if we're updating existing note
        // we need to preserve the ids, otherwise can result in data conflict
        let noDelete = false;
        if ((maybeNote === null || maybeNote === void 0 ? void 0 : maybeNote.stub) || (opts === null || opts === void 0 ? void 0 : opts.updateExisting)) {
            note = { ...maybeNote, ...note };
            note = lodash_1.default.omit(note, "stub");
            if (opts === null || opts === void 0 ? void 0 : opts.updateExisting)
                noDelete = true;
        }
        if (!(opts === null || opts === void 0 ? void 0 : opts.updateExisting)) {
            changedEntries = await this._writeNewNote({
                note,
                existingNote: maybeNote,
                opts,
            });
        }
        // add schema if applicable
        const schemaMatch = common_all_1.SchemaUtils.matchPath({
            notePath: note.fname,
            schemaModDict: this.schemas,
        });
        this.logger.info({
            ctx,
            msg: "pre:note2File",
        });
        if ((opts === null || opts === void 0 ? void 0 : opts.runHooks) === false) {
            this.logger.info({
                ctx,
                msg: "hooks disabled for write",
            });
        }
        else {
            const hooks = lodash_1.default.filter(this.engine.hooks.onCreate, (hook) => common_all_1.NoteUtils.match({ notePath: note.fname, pattern: hook.pattern }));
            const resp = await lodash_1.default.reduce(hooks, async (notePromise, hook) => {
                const { note } = await notePromise;
                const script = hooks_1.HookUtils.getHookScriptPath({
                    wsRoot: this.wsRoot,
                    basename: hook.id + ".js",
                });
                return hooks_1.HookUtils.requireHook({
                    note,
                    fpath: script,
                    wsRoot: this.wsRoot,
                });
            }, Promise.resolve({ note })).catch((err) => new common_all_1.DendronError({
                severity: common_all_1.ERROR_SEVERITY.MINOR,
                message: "error with hook",
                payload: (0, common_all_1.stringifyError)(err),
            }));
            if (resp instanceof common_all_1.DendronError) {
                error = resp;
                this.logger.error({ ctx, error: (0, common_all_1.stringifyError)(error) });
            }
            else {
                const valResp = common_all_1.NoteUtils.validate(resp.note);
                if (valResp instanceof common_all_1.DendronError) {
                    error = valResp;
                    this.logger.error({ ctx, error: (0, common_all_1.stringifyError)(error) });
                }
                else {
                    note = resp.note;
                    this.logger.info({ ctx, msg: "fin:RunHooks", payload: resp.payload });
                }
            }
        }
        // order matters - only write file after parents are established @see(_writeNewNote)
        const hash = await (0, common_server_1.note2File)({
            note,
            vault: note.vault,
            wsRoot: this.wsRoot,
        });
        note.contentHash = hash;
        // schema metadata is only applicable at runtime
        // we therefore write it after we persist note to store
        if (schemaMatch) {
            this.logger.info({
                ctx,
                msg: "pre:addSchema",
            });
            const { schema, schemaModule } = schemaMatch;
            common_all_1.NoteUtils.addSchema({ note, schema, schemaModule });
        }
        // if we added a new note and it overwrote an existing note
        // we now need to update the metadata of existing notes ^change
        // TODO: Not sure the this.updateNote(ent) call is necessary, since it's already updated via _writeNewNote above.
        this.logger.info({
            ctx,
            msg: "pre:updateNotes",
        });
        await Promise.all([note]
            .concat(changedEntries.map((entry) => entry.note))
            .map((ent) => this.updateNote(ent)));
        if (maybeNote && !noDelete) {
            changedEntries.push({ note: maybeNote, status: "delete" });
        }
        changedEntries.push({ note, status: "create" });
        this.logger.info({
            ctx,
            msg: "exit",
        });
        return {
            error,
            data: changedEntries,
        };
    }
    async writeSchema(schemaModule) {
        this.schemas[schemaModule.root.id] = schemaModule;
        const vault = schemaModule.vault;
        const vpath = (0, common_server_1.vault2Path)({ vault, wsRoot: this.wsRoot });
        await (0, common_server_1.schemaModuleProps2File)(schemaModule, vpath, schemaModule.fname);
    }
}
exports.FileStorage = FileStorage;
//# sourceMappingURL=storev2.js.map