"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createEngineV3 = exports.DendronEngineV3 = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const lodash_1 = __importDefault(require("lodash"));
const store_1 = require("./store");
const config_1 = require("./config");
const markdown_1 = require("./markdown");
const NoteMetadataStore_1 = require("./store/NoteMetadataStore");
const hooks_1 = require("./topics/hooks");
const NoteParserV2_1 = require("./drivers/file/NoteParserV2");
const path_1 = __importDefault(require("path"));
const notesFileSystemCache_1 = require("./cache/notesFileSystemCache");
const storev2_1 = require("./drivers/file/storev2");
class DendronEngineV3 {
    constructor(props) {
        this.wsRoot = props.wsRoot;
        this.configRoot = props.wsRoot;
        this.logger = props.logger;
        this.props = props;
        this.fuseEngine = new common_all_1.FuseEngine({
            fuzzThreshold: common_all_1.ConfigUtils.getLookup(props.config).note.fuzzThreshold,
        });
        this.links = [];
        this.config = props.config;
        this._vaults = props.vaults;
        const hooks = common_all_1.ConfigUtils.getWorkspace(props.config).hooks || {
            onCreate: [],
        };
        this.hooks = hooks;
        this._fileStore = props.fileStore;
        this._noteStore = props.noteStore;
        // TODO: remove after migration
        this.store = new storev2_1.FileStorage({
            engine: this,
            logger: this.logger,
        });
    }
    static create({ wsRoot, logger }) {
        const LOGGER = logger || (0, common_server_1.createLogger)();
        const { error, data: config } = config_1.DConfig.readConfigAndApplyLocalOverrideSync(wsRoot);
        if (error) {
            LOGGER.error((0, common_all_1.stringifyError)(error));
        }
        const fileStore = new store_1.NodeJSFileStore();
        return new DendronEngineV3({
            wsRoot,
            vaults: common_all_1.ConfigUtils.getVaults(config),
            forceNew: true,
            noteStore: new store_1.NoteStore({
                fileStore,
                dataStore: new NoteMetadataStore_1.NoteMetadataStore(),
                wsRoot,
            }),
            fileStore,
            mode: "fuzzy",
            logger: LOGGER,
            config,
        });
    }
    static instance({ wsRoot }) {
        if (!DendronEngineV3._instance) {
            DendronEngineV3._instance = DendronEngineV3.create({ wsRoot });
        }
        return DendronEngineV3._instance;
    }
    /**
     * @deprecated
     * For accessing a specific note by id, see {@link DendronEngineV3.getNote}.
     * If you need all notes, avoid modifying any note as this will cause unintended changes on the store side
     */
    get notes() {
        return this.store.notes;
    }
    /**
     * @deprecated see {@link DendronEngineV3.findNotes}
     */
    get noteFnames() {
        return this.store.noteFnames;
    }
    get schemas() {
        return this.store.schemas;
    }
    get vaults() {
        return this._vaults;
    }
    set vaults(vaults) {
        this._vaults = vaults;
    }
    /**
     * Does not throw error but returns it
     */
    async init() {
        try {
            const { data: notes, error: storeError } = await this.initNotes();
            // TODO: add schemas to notes
            const schemas = {};
            if (lodash_1.default.isUndefined(notes)) {
                return {
                    error: common_all_1.DendronError.createFromStatus({
                        status: common_all_1.ERROR_STATUS.UNKNOWN,
                        severity: common_all_1.ERROR_SEVERITY.FATAL,
                    }),
                };
            }
            this.fuseEngine.updateNotesIndex(notes);
            const bulkWriteOpts = lodash_1.default.values(notes).map((note) => {
                const noteMeta = lodash_1.default.omit(note, ["body", "contentHash"]);
                return { key: note.id, noteMeta };
            });
            this._noteStore.bulkWriteMetadata(bulkWriteOpts);
            // TODO: update schema index
            //this.updateIndex("schema");
            const hookErrors = [];
            this.hooks.onCreate = this.hooks.onCreate.filter((hook) => {
                const { valid, error } = hooks_1.HookUtils.validateHook({
                    hook,
                    wsRoot: this.wsRoot,
                });
                if (!valid && error) {
                    this.logger.error({ msg: "bad hook", hook, error });
                    hookErrors.push(error);
                }
                return valid;
            });
            const allErrors = storeError
                ? hookErrors.concat(storeError.errors)
                : hookErrors;
            let error;
            switch (lodash_1.default.size(allErrors)) {
                case 0: {
                    error = null;
                    break;
                }
                case 1: {
                    error = new common_all_1.DendronError(allErrors[0]);
                    break;
                }
                default:
                    error = new common_all_1.DendronCompositeError(allErrors);
            }
            this.logger.info({ ctx: "init:ext", error, storeError, hookErrors });
            return {
                error,
                data: {
                    notes,
                    schemas,
                    wsRoot: this.wsRoot,
                    vaults: this.vaults,
                    config: this.config,
                },
            };
        }
        catch (error) {
            const { message, stack, status } = error;
            const payload = { message, stack };
            return {
                error: common_all_1.DendronError.createPlainError({
                    payload,
                    message,
                    status,
                    severity: common_all_1.ERROR_SEVERITY.FATAL,
                }),
            };
        }
    }
    /**
     * See {@link DEngine.getNote}
     */
    async getNote(id) {
        const resp = await this._noteStore.get(id);
        return resp.data;
    }
    /**
     * See {@link DEngine.findNotes}
     */
    async findNotes(opts) {
        const resp = await this._noteStore.find(opts);
        return resp.data ? resp.data : [];
    }
    /**
     * See {@link DEngine.findNotesMeta}
     */
    async findNotesMeta(opts) {
        const resp = await this._noteStore.findMetaData(opts);
        return resp.data ? resp.data : [];
    }
    async bulkWriteNotes() {
        throw new Error("bulkWriteNotes not implemented");
    }
    async deleteNote() {
        throw Error("deleteNote not implemented");
    }
    async deleteSchema() {
        throw Error("deleteSchema not implemented");
    }
    async getConfig() {
        const cpath = config_1.DConfig.configPath(this.configRoot);
        const config = lodash_1.default.defaultsDeep((0, common_server_1.readYAML)(cpath), common_all_1.ConfigUtils.genDefaultConfig());
        return {
            error: null,
            data: config,
        };
    }
    async getSchema() {
        throw Error("getSchema not implemented");
    }
    async info() {
        const version = common_server_1.NodeJSUtils.getVersionFromPkg();
        if (!version) {
            return {
                data: undefined,
                error: common_all_1.DendronError.createPlainError({
                    message: "Unable to read Dendron version",
                }),
            };
        }
        return {
            data: {
                version,
            },
            error: null,
        };
    }
    queryNotesSync() {
        throw Error("queryNotesSync not implemented");
    }
    async querySchema() {
        throw Error("querySchema not implemented");
    }
    async queryNotes() {
        throw Error("queryNotes not implemented");
    }
    async renderNote() {
        throw Error("renderNote not implemented");
    }
    async sync() {
        throw Error("sync not implemented");
    }
    async refreshNotes() {
        throw new Error("sync not implemented");
    }
    async renameNote() {
        throw Error("renameNote not implemented");
    }
    async updateNote() {
        throw new Error("updateNote not implemented");
    }
    async updateSchema() {
        throw Error("updateSchema not implemented");
    }
    async writeConfig() {
        throw Error("writeConfig not implemented");
    }
    async addAccessTokensToPodConfig() {
        throw Error("addAccessTokensToPodConfig not implemented");
    }
    async writeNote() {
        throw Error("writeNote not implemented");
    }
    async writeSchema() {
        throw Error("writeSchema not implemented");
    }
    async getNoteBlocks() {
        throw Error("getNoteBlocks not implemented");
    }
    async getDecorations() {
        throw Error("getDecorations not implemented");
    }
    /**
     * TODO: Fix backlinks not being updated when adding new reference to another note or renaming old reference
     */
    async getLinks(opts) {
        const { type, note } = opts;
        let links;
        switch (type) {
            case "regular":
                links = markdown_1.LinkUtils.findLinks({
                    note,
                    engine: this,
                });
                break;
            case "candidate":
                links = markdown_1.LinkUtils.findLinkCandidates({
                    note,
                    engine: this,
                });
                break;
            default:
                (0, common_all_1.assertUnreachable)(type);
        }
        const backlinks = note.links.filter((link) => link.type === "backlink");
        return { data: links.concat(backlinks), error: null };
    }
    async getAnchors(opts) {
        return {
            data: markdown_1.AnchorUtils.findAnchors({
                note: opts.note,
            }),
            error: null,
        };
    }
    /**
     * Construct dictionary of NoteProps from workspace on filesystem
     *
     * For every vault on the filesystem, get list of files and convert each file to NoteProp
     * @returns NotePropsByIdDict
     */
    async initNotes() {
        const ctx = "DendronEngineV3:initNotes";
        this.logger.info({ ctx, msg: "enter" });
        let errors = [];
        let notesFname = {};
        const start = process.hrtime();
        const allNotesList = await Promise.all(this.vaults.map(async (vault) => {
            const vpath = (0, common_server_1.vault2Path)({ vault, wsRoot: this.wsRoot });
            // Get list of files from filesystem
            const maybeFiles = await this._fileStore.readDir({
                root: vpath,
                include: ["*.md"],
            });
            if (maybeFiles.error) {
                // Keep initializing other vaults
                errors = errors.concat([
                    new common_all_1.DendronError({
                        message: `Unable to read notes for vault ${common_all_1.VaultUtils.getName(vault)}`,
                        severity: common_all_1.ERROR_SEVERITY.MINOR,
                        payload: maybeFiles.error,
                    }),
                ]);
                return {};
            }
            // Load cache from vault
            const cachePath = path_1.default.join(vpath, common_all_1.CONSTANTS.DENDRON_CACHE_FILE);
            const notesCache = new notesFileSystemCache_1.NotesFileSystemCache({
                cachePath,
                noCaching: this.config.noCaching,
                logger: this.logger,
            });
            const { data: notesDict, error } = await new NoteParserV2_1.NoteParserV2({
                cache: notesCache,
                engine: this,
                logger: this.logger,
                maxNoteLength: common_all_1.ConfigUtils.getWorkspace(this.config).maxNoteLength,
            }).parseFiles(maybeFiles.data, vault);
            if (error) {
                errors = errors.concat(error === null || error === void 0 ? void 0 : error.errors);
            }
            if (notesDict) {
                const { notesById, notesByFname } = notesDict;
                notesFname = common_all_1.NoteFnameDictUtils.merge(notesFname, notesByFname);
                this.logger.info({
                    ctx,
                    vault,
                    numEntries: lodash_1.default.size(notesById),
                    numCacheUpdates: notesCache.numCacheMisses,
                });
                return notesById;
            }
            return {};
        }));
        const allNotes = Object.assign({}, ...allNotesList);
        const notesWithLinks = lodash_1.default.filter(allNotes, (note) => !lodash_1.default.isEmpty(note.links));
        this.addBacklinks({
            notesById: allNotes,
            notesByFname: notesFname,
        }, notesWithLinks);
        const duration = (0, common_server_1.getDurationMilliseconds)(start);
        this.logger.info({ ctx, msg: `time to init notes: "${duration}" ms` });
        return {
            data: allNotes,
            error: new common_all_1.DendronCompositeError(errors),
        };
    }
    /**
     * Create and add backlinks from all notes with a link pointing to another note
     */
    addBacklinks(noteDicts, notesWithLinks) {
        notesWithLinks.forEach((noteFrom) => {
            try {
                noteFrom.links.forEach((link) => {
                    var _a;
                    const fname = (_a = link.to) === null || _a === void 0 ? void 0 : _a.fname;
                    // Note referencing itself does not count as backlink
                    if (fname && fname !== noteFrom.fname) {
                        const notes = common_all_1.NoteDictsUtils.findByFname(fname, noteDicts);
                        notes.forEach((noteTo) => {
                            common_all_1.NoteUtils.addBacklink({
                                from: noteFrom,
                                to: noteTo,
                                link,
                            });
                        });
                    }
                });
            }
            catch (err) {
                const error = (0, common_all_1.error2PlainObject)(err);
                this.logger.error({ error, noteFrom, message: "issue with backlinks" });
            }
        });
    }
}
exports.DendronEngineV3 = DendronEngineV3;
const createEngineV3 = ({ wsRoot }) => {
    const engine = DendronEngineV3.create({ wsRoot });
    return engine;
};
exports.createEngineV3 = createEngineV3;
//# sourceMappingURL=DendronEngineV3.js.map