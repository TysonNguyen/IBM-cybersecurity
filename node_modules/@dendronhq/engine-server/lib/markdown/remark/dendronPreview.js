"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.dendronHoverPreview = exports.makeImageUrlFullPath = void 0;
const common_server_1 = require("@dendronhq/common-server");
const lodash_1 = __importDefault(require("lodash"));
const types_1 = require("../types");
const path_1 = __importDefault(require("path"));
const unist_util_visit_1 = __importDefault(require("unist-util-visit"));
const _1 = require(".");
const utilsv5_1 = require("../utilsv5");
/** Makes the `.url` of the given image note a full path. */
function makeImageUrlFullPath({ proc, node, }) {
    // ignore web images
    if (lodash_1.default.some(["http://", "https://"], (ent) => node.url.startsWith(ent))) {
        return;
    }
    // assume that the path is relative to vault
    const { wsRoot, vault } = utilsv5_1.MDUtilsV5.getProcData(proc);
    const fpath = path_1.default.join((0, common_server_1.vault2Path)({ wsRoot, vault }), node.url);
    node.url = fpath;
}
exports.makeImageUrlFullPath = makeImageUrlFullPath;
function dendronHoverPreview(_opts) {
    const proc = this;
    function transformer(tree, _file) {
        (0, unist_util_visit_1.default)(tree, [
            types_1.DendronASTTypes.FRONTMATTER,
            types_1.DendronASTTypes.IMAGE,
            types_1.DendronASTTypes.EXTENDED_IMAGE,
        ], (node, index, parent) => {
            // Remove the frontmatter because it will break the output
            if (_1.RemarkUtils.isFrontmatter(node) && parent) {
                // Remove this node
                parent.children.splice(index, 1);
                // Since this removes the frontmatter node, the next node to visit is at the same index.
                return index;
            }
            if (_1.RemarkUtils.isImage(node) || _1.RemarkUtils.isExtendedImage(node)) {
                makeImageUrlFullPath({ proc, node });
            }
            return undefined; // continue
        });
    }
    return transformer;
}
exports.dendronHoverPreview = dendronHoverPreview;
//# sourceMappingURL=dendronPreview.js.map