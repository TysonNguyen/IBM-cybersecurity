"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MIGRATION_ENTRIES = exports.CONFIG_MIGRATIONS = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const lodash_1 = __importDefault(require("lodash"));
const config_1 = require("../config");
const utils_1 = require("../utils");
const utils_2 = require("./utils");
const _1 = require(".");
exports.CONFIG_MIGRATIONS = {
    version: "0.83.0",
    changes: [
        {
            name: "migrate config",
            func: async ({ dendronConfig, wsConfig, wsService }) => {
                try {
                    await config_1.DConfig.createBackup(wsService.wsRoot, "migrate-configs");
                }
                catch (error) {
                    return {
                        data: {
                            dendronConfig,
                            wsConfig,
                        },
                        error: new common_all_1.DendronError({
                            message: "Backup failed during config migration. Exiting without migration.",
                        }),
                    };
                }
                const defaultV5Config = common_all_1.ConfigUtils.genDefaultConfig();
                const rawDendronConfig = config_1.DConfig.getRaw(wsService.wsRoot);
                // remove all null properties
                const cleanDendronConfig = utils_2.MigrationUtils.deepCleanObjBy(rawDendronConfig, lodash_1.default.isNull);
                if (lodash_1.default.isUndefined(cleanDendronConfig.commands)) {
                    cleanDendronConfig.commands = {};
                }
                if (lodash_1.default.isUndefined(cleanDendronConfig.workspace)) {
                    cleanDendronConfig.workspace = {};
                }
                if (lodash_1.default.isUndefined(cleanDendronConfig.preview)) {
                    cleanDendronConfig.preview = {};
                }
                if (lodash_1.default.isUndefined(cleanDendronConfig.publishing)) {
                    cleanDendronConfig.publishing = {};
                }
                // legacy paths to remove from config;
                const legacyPaths = [];
                // migrate each path mapped in current config version
                utils_2.PATH_MAP.forEach((value, key) => {
                    const { target: legacyPath, preserve } = value;
                    let iteratee = value.iteratee;
                    let valueToFill;
                    let alreadyFilled;
                    if (iteratee !== "skip") {
                        alreadyFilled = lodash_1.default.has(cleanDendronConfig, key);
                        const maybeLegacyConfig = lodash_1.default.get(cleanDendronConfig, legacyPath);
                        if (lodash_1.default.isUndefined(maybeLegacyConfig)) {
                            // legacy property doesn't have a value.
                            valueToFill = lodash_1.default.get(defaultV5Config, key);
                        }
                        else {
                            // there is a legacy value.
                            // check if this mapping needs special treatment.
                            if (lodash_1.default.isUndefined(iteratee)) {
                                // assume identity mapping.
                                iteratee = lodash_1.default.identity;
                            }
                            valueToFill = iteratee(maybeLegacyConfig);
                        }
                    }
                    if (!alreadyFilled && !lodash_1.default.isUndefined(valueToFill)) {
                        // if the property isn't already filled, fill it with determined value.
                        lodash_1.default.set(cleanDendronConfig, key, valueToFill);
                    }
                    // these will later be used to delete.
                    // only push if we aren't preserving target.
                    if (!preserve) {
                        legacyPaths.push(legacyPath);
                    }
                });
                // set config version.
                lodash_1.default.set(cleanDendronConfig, "version", 5);
                // add deprecated paths to legacyPaths
                // so they could be unset if they exist
                legacyPaths.push(..._1.DEPRECATED_PATHS);
                // remove legacy property from config after migration.
                legacyPaths.forEach((legacyPath) => {
                    lodash_1.default.unset(cleanDendronConfig, legacyPath);
                });
                // recursively populate missing defaults
                const migratedConfig = lodash_1.default.defaultsDeep(cleanDendronConfig, defaultV5Config);
                return { data: { dendronConfig: migratedConfig, wsConfig } };
            },
        },
    ],
};
/**
 * Migrations are sorted by version numbers, from greatest to least
 */
const ALL_MIGRATIONS = [
    // CONFIG_MIGRATIONS,
    {
        version: "0.55.2",
        changes: [
            {
                name: "migrate note lookup config",
                func: async ({ dendronConfig, wsConfig }) => {
                    const oldLookupCreateBehavior = lodash_1.default.get(wsConfig === null || wsConfig === void 0 ? void 0 : wsConfig.settings, "dendron.defaultLookupCreateBehavior", undefined);
                    if (oldLookupCreateBehavior !== undefined) {
                        let newValue;
                        switch (oldLookupCreateBehavior) {
                            case "selection2link": {
                                newValue = common_all_1.LookupSelectionModeEnum.link;
                                break;
                            }
                            case "none": {
                                newValue = common_all_1.LookupSelectionModeEnum.none;
                                break;
                            }
                            case "selectionExtract":
                            default: {
                                newValue = common_all_1.LookupSelectionModeEnum.extract;
                                break;
                            }
                        }
                        common_all_1.ConfigUtils.setNoteLookupProps(dendronConfig, "selectionMode", newValue);
                    }
                    return { data: { dendronConfig, wsConfig } };
                },
            },
        ],
    },
    {
        version: "0.51.4",
        changes: [
            {
                name: "migrate scratch config",
                func: async ({ dendronConfig, wsConfig }) => {
                    const wsName = lodash_1.default.get(wsConfig === null || wsConfig === void 0 ? void 0 : wsConfig.settings, "dendron.defaultScratchName");
                    if (wsName) {
                        common_all_1.ConfigUtils.setScratchProps(dendronConfig, "name", wsName);
                    }
                    const wsDateFormat = lodash_1.default.get(wsConfig === null || wsConfig === void 0 ? void 0 : wsConfig.settings, "dendron.defaultScratchDateFormat");
                    if (wsDateFormat) {
                        common_all_1.ConfigUtils.setScratchProps(dendronConfig, "dateFormat", wsDateFormat);
                    }
                    const wsAddBehavior = lodash_1.default.get(wsConfig === null || wsConfig === void 0 ? void 0 : wsConfig.settings, "dendron.defaultScratchAddBehavior");
                    if (wsAddBehavior) {
                        common_all_1.ConfigUtils.setScratchProps(dendronConfig, "addBehavior", wsAddBehavior);
                    }
                    return { data: { dendronConfig, wsConfig } };
                },
            },
        ],
    },
    {
        version: "0.47.1",
        changes: [
            {
                name: "migrate journal config",
                func: async ({ dendronConfig, wsConfig }) => {
                    const wsDailyDomain = lodash_1.default.get(wsConfig === null || wsConfig === void 0 ? void 0 : wsConfig.settings, "dendron.dailyJournalDomain");
                    if (wsDailyDomain) {
                        common_all_1.ConfigUtils.setJournalProps(dendronConfig, "dailyDomain", wsDailyDomain);
                    }
                    const wsName = lodash_1.default.get(wsConfig === null || wsConfig === void 0 ? void 0 : wsConfig.settings, "dendron.defaultJournalName");
                    if (wsName) {
                        common_all_1.ConfigUtils.setJournalProps(dendronConfig, "name", wsName);
                    }
                    const wsDateFormat = lodash_1.default.get(wsConfig === null || wsConfig === void 0 ? void 0 : wsConfig.settings, "dendron.defaultJournalDateFormat");
                    if (wsDateFormat) {
                        common_all_1.ConfigUtils.setJournalProps(dendronConfig, "dateFormat", wsDateFormat);
                    }
                    const wsAddBehavior = lodash_1.default.get(wsConfig === null || wsConfig === void 0 ? void 0 : wsConfig.settings, "dendron.defaultJournalAddBehavior");
                    if (wsAddBehavior) {
                        common_all_1.ConfigUtils.setJournalProps(dendronConfig, "addBehavior", wsAddBehavior);
                    }
                    return { data: { dendronConfig, wsConfig } };
                },
            },
        ],
    },
    {
        version: "0.46.0",
        changes: [
            {
                name: "update cache",
                func: async ({ dendronConfig, wsConfig, wsService }) => {
                    const { wsRoot, config } = wsService;
                    const vaults = common_all_1.ConfigUtils.getVaults(config);
                    await Promise.all(vaults.map((vault) => {
                        return (0, utils_1.removeCache)((0, common_server_1.vault2Path)({ wsRoot, vault }));
                    }));
                    const segStatus = common_server_1.SegmentClient.getStatus();
                    // use has not disabled telemetry prior to upgrade
                    if (segStatus !== common_server_1.TelemetryStatus.DISABLED_BY_COMMAND &&
                        !common_all_1.ConfigUtils.getWorkspace(config).disableTelemetry) {
                        common_server_1.SegmentClient.enable(common_server_1.TelemetryStatus.ENABLED_BY_MIGRATION);
                    }
                    return { data: { dendronConfig, wsConfig } };
                },
            },
        ],
    },
];
exports.MIGRATION_ENTRIES = [exports.CONFIG_MIGRATIONS, ...ALL_MIGRATIONS];
//# sourceMappingURL=migrations.js.map