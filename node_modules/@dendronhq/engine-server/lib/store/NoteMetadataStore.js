"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoteMetadataStore = void 0;
const common_all_1 = require("@dendronhq/common-all");
const lodash_1 = __importDefault(require("lodash"));
class NoteMetadataStore {
    constructor() {
        this._noteMetadataById = {};
        this._noteIdsByFname = {};
    }
    /**
     * See {@link IDataStore.get}
     */
    async get(key) {
        const maybeNote = this._noteMetadataById[key];
        if (maybeNote) {
            return { data: lodash_1.default.cloneDeep(maybeNote) };
        }
        else {
            return {
                error: common_all_1.DendronError.createFromStatus({
                    status: common_all_1.ERROR_STATUS.CONTENT_NOT_FOUND,
                    message: `NoteProps metadata not found for key ${key}.`,
                    severity: common_all_1.ERROR_SEVERITY.MINOR,
                }),
            };
        }
    }
    /**
     * See {@link IDataStore.find}
     */
    async find(opts) {
        const { fname, vault } = opts;
        let noteMetadata = [];
        if (fname) {
            const cleanedFname = (0, common_all_1.cleanName)(fname);
            const ids = this._noteIdsByFname[cleanedFname];
            if (!ids) {
                return { data: [] };
            }
            noteMetadata = ids
                .map((id) => this._noteMetadataById[id])
                .filter(common_all_1.isNotUndefined);
            if (vault) {
                noteMetadata = noteMetadata.filter((note) => common_all_1.VaultUtils.isEqualV2(note.vault, vault));
            }
            return { data: lodash_1.default.cloneDeep(noteMetadata) };
        }
        else if (vault) {
            noteMetadata = lodash_1.default.values(this._noteMetadataById).filter((note) => common_all_1.VaultUtils.isEqualV2(note.vault, vault));
        }
        return { data: noteMetadata };
    }
    /**
     * See {@link IDataStore.write}
     *
     * Add note to _noteMetadataById and _noteIdsByFname.
     * If note id already exists, check to see if it corresponds to same note by fname.
     * If fname match, then we only need to update _noteMetadataById. If fname doesn't match, remove old id from _noteIdsByFname first before updating both.
     *
     * Otherwise, if note id doesn't exist, add to both dictionaries
     */
    async write(key, data) {
        const maybeNote = this._noteMetadataById[data.id];
        if (maybeNote) {
            if ((0, common_all_1.cleanName)(maybeNote.fname) === (0, common_all_1.cleanName)(data.fname)) {
                this._noteMetadataById[data.id] = data;
                return { data: key };
            }
            else {
                // Remove old fname from fname dict
                common_all_1.NoteFnameDictUtils.delete(maybeNote, this._noteIdsByFname);
            }
        }
        this._noteMetadataById[data.id] = data;
        common_all_1.NoteFnameDictUtils.add(data, this._noteIdsByFname);
        return { data: key };
    }
    /**
     * See {@link IDataStore.delete}
     *
     * Remove note from both _noteMetadataById and _noteIdsByFname.
     */
    async delete(key) {
        const maybeNote = this._noteMetadataById[key];
        if (maybeNote) {
            common_all_1.NoteFnameDictUtils.delete(maybeNote, this._noteIdsByFname);
        }
        delete this._noteMetadataById[key];
        return { data: key };
    }
}
exports.NoteMetadataStore = NoteMetadataStore;
//# sourceMappingURL=NoteMetadataStore.js.map