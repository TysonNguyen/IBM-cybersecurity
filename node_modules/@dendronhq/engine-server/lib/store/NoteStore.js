"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoteStore = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const lodash_1 = __importDefault(require("lodash"));
/**
 * Responsible for storing NoteProps non-metadata and NoteProps metadata
 */
class NoteStore {
    constructor(opts) {
        this._fileStore = opts.fileStore;
        this._metadataStore = opts.dataStore;
        this._wsRoot = opts.wsRoot;
        const { logger, dispose } = (0, common_server_1.createDisposableLogger)();
        this._logger = logger;
        this._loggerDispose = dispose;
    }
    dispose() {
        this._loggerDispose();
    }
    /**
     * See {@link INoteStore.get}
     */
    async get(key) {
        const ctx = "NoteStore:get";
        this._logger.info({ ctx, msg: `Getting NoteProps for ${key}` });
        const metadata = await this.getMetadata(key);
        if (metadata.error) {
            return { error: metadata.error };
        }
        const uri = common_all_1.NoteUtils.getURI({ note: metadata.data, wsRoot: this._wsRoot });
        const nonMetadata = await this._fileStore.read(uri);
        if (nonMetadata.error) {
            return { error: nonMetadata.error };
        }
        // Parse file for note body since we don't have that in metadata
        const capture = nonMetadata.data.match(/^---[\s\S]+?---/);
        if (capture) {
            const offset = capture[0].length;
            const body = nonMetadata.data.slice(offset + 1);
            // add `contentHash` to this signature because its not saved with metadata
            const note = {
                ...metadata.data,
                body,
                contentHash: (0, common_all_1.genHash)(nonMetadata.data),
            };
            return { data: note };
        }
        else {
            return {
                error: common_all_1.DendronError.createFromStatus({
                    status: common_all_1.ERROR_STATUS.BAD_PARSE_FOR_NOTE,
                    message: `Frontmatter missing for file ${uri.fsPath} associated with note ${key}.`,
                    severity: common_all_1.ERROR_SEVERITY.MINOR,
                }),
            };
        }
    }
    /**
     * See {@link INoteStore.bulkGet}
     */
    async bulkGet(keys) {
        const ctx = "NoteStore:bulkGet";
        this._logger.info({ ctx, msg: `Bulk getting NoteProps for ${keys}` });
        return Promise.all(keys.map((key) => this.get(key)));
    }
    /**
     * See {@link INoteStore.getMetadata}
     */
    async getMetadata(key) {
        const resp = await this._metadataStore.get(key);
        if (resp.error) {
            return { error: resp.error };
        }
        return { data: resp.data };
    }
    /**
     * See {@link INoteStore.find}
     */
    async find(opts) {
        const noteMetadata = await this.findMetaData(opts);
        if (noteMetadata.error) {
            return { error: new common_all_1.DendronCompositeError([noteMetadata.error]) };
        }
        const responses = await Promise.all(noteMetadata.data.map((noteMetadata) => this.get(noteMetadata.id)));
        const errors = [];
        const data = [];
        responses.forEach((resp) => {
            if (resp.error) {
                errors.push(resp.error);
            }
            else {
                data.push(resp.data);
            }
        });
        return {
            error: errors.length > 0 ? new common_all_1.DendronCompositeError(errors) : null,
            data: data.filter(common_all_1.isNotUndefined),
        };
    }
    /**
     * See {@link INoteStore.findMetaData}
     */
    async findMetaData(opts) {
        const resp = await this._metadataStore.find(opts);
        if (resp.error) {
            return { error: resp.error };
        }
        return { data: resp.data };
    }
    /**
     * See {@link INoteStore.write}
     */
    async write(opts) {
        const { key, note } = opts;
        const noteMeta = lodash_1.default.omit(note, ["body", "contentHash"]);
        const metaResp = await this.writeMetadata({ key, noteMeta });
        if (metaResp.error) {
            return { error: metaResp.error };
        }
        const uri = common_all_1.NoteUtils.getURI({ note, wsRoot: this._wsRoot });
        const content = common_all_1.NoteUtils.serialize(note, { excludeStub: true });
        const writeResp = await this._fileStore.write(uri, content);
        if (writeResp.error) {
            return { error: writeResp.error };
        }
        return { data: key };
    }
    /**s
     * See {@link INoteStore.writeMetadata}
     */
    async writeMetadata(opts) {
        const { key, noteMeta } = opts;
        // Ids don't match, return error
        if (key !== noteMeta.id) {
            return {
                error: common_all_1.DendronError.createFromStatus({
                    status: common_all_1.ERROR_STATUS.WRITE_FAILED,
                    message: `Ids don't match between key ${key} and note meta ${noteMeta}.`,
                    severity: common_all_1.ERROR_SEVERITY.MINOR,
                }),
            };
        }
        const metaResp = await this._metadataStore.write(key, noteMeta);
        if (metaResp.error) {
            return { error: metaResp.error };
        }
        return { data: key };
    }
    /**s
     * See {@link INoteStore.bulkWriteMetadata}
     */
    async bulkWriteMetadata(opts) {
        return Promise.all(opts.map((writeMetaOpt) => {
            return this.writeMetadata(writeMetaOpt);
        }));
    }
    /**
     * See {@link INoteStore.delete}
     */
    async delete(key) {
        const metadata = await this.getMetadata(key);
        if (metadata.error) {
            return { error: metadata.error };
        }
        const uri = common_all_1.NoteUtils.getURI({ note: metadata.data, wsRoot: this._wsRoot });
        const deleteResp = await this._fileStore.delete(uri);
        if (deleteResp.error) {
            return { error: deleteResp.error };
        }
        const metaResp = await this._metadataStore.delete(key);
        if (metaResp.error) {
            return { error: metaResp.error };
        }
        return { data: key };
    }
    async rename(oldLoc, newLoc) {
        // TODO: implement
        const test = oldLoc.fname + newLoc.fname;
        return { data: test };
    }
}
exports.NoteStore = NoteStore;
//# sourceMappingURL=NoteStore.js.map