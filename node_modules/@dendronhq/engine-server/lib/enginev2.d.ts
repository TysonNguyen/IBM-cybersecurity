import { BulkWriteNotesOpts, ConfigWriteOpts, DEngine, DEngineClient, DEngineDeleteSchemaResp, DEngineInitResp, DEngineMode, DHookDict, DLink, DNodeType, DStore, DVault, EngineDeleteOpts, EngineInfoResp, EngineUpdateNodesOptsV2, EngineWriteOptsV2, FindNoteOpts, FuseEngine, GetAnchorsRequest, GetDecorationsOpts, GetDecorationsPayload, GetLinksRequest, GetNoteAnchorsPayload, GetNoteBlocksOpts, GetNoteBlocksPayload, GetNoteLinksPayload, IntermediateDendronConfig, NoteChangeEntry, NoteProps, NotePropsByIdDict, NotePropsMeta, NoteQueryResp, Optional, QueryNotesOpts, RefreshNotesOpts, RenameNoteOpts, RenameNotePayload, RenderNoteOpts, RenderNotePayload, RespV2, SchemaModuleDict, SchemaModuleProps, SchemaQueryResp, WorkspaceOpts, WriteNoteResp } from "@dendronhq/common-all";
import { DLogger } from "@dendronhq/common-server";
declare type CreateStoreFunc = (engine: DEngineClient) => DStore;
declare type DendronEngineOptsV2 = {
    wsRoot: string;
    vaults: DVault[];
    forceNew?: boolean;
    createStore?: CreateStoreFunc;
    mode?: DEngineMode;
    logger?: DLogger;
    config: IntermediateDendronConfig;
};
declare type DendronEnginePropsV2 = Required<DendronEngineOptsV2>;
export declare class DendronEngineV2 implements DEngine {
    wsRoot: string;
    store: DStore;
    protected props: DendronEnginePropsV2;
    logger: DLogger;
    fuseEngine: FuseEngine;
    links: DLink[];
    configRoot: string;
    config: IntermediateDendronConfig;
    hooks: DHookDict;
    private _vaults;
    private renderedCache;
    static _instance: DendronEngineV2 | undefined;
    constructor(props: DendronEnginePropsV2);
    /**
     * TODO: Fix backlinks not being updated when adding new reference to another note or renaming old reference
     */
    getLinks(opts: Optional<GetLinksRequest, "ws">): Promise<GetNoteLinksPayload>;
    getAnchors(opts: GetAnchorsRequest): Promise<GetNoteAnchorsPayload>;
    static create({ wsRoot, logger }: {
        logger?: DLogger;
        wsRoot: string;
    }): DendronEngineV2;
    static instance({ wsRoot }: {
        wsRoot: string;
    }): DendronEngineV2;
    /**
     * @deprecated
     * For accessing a specific note by id, see {@link DendronEngineV2.getNote}.
     * If you need all notes, avoid modifying any note as this will cause unintended changes on the store side
     */
    get notes(): NotePropsByIdDict;
    /**
     * @deprecated see {@link DendronEngineV2.findNotes}
     */
    get noteFnames(): import("@dendronhq/common-all").NotePropsByFnameDict;
    get schemas(): SchemaModuleDict;
    get vaults(): DVault[];
    set notes(notes: NotePropsByIdDict);
    set vaults(vaults: DVault[]);
    /**
     * Does not throw error but returns it
     */
    init(): Promise<DEngineInitResp>;
    /**
     * See {@link DEngine.getNote}
     */
    getNote(id: string): Promise<NoteProps | undefined>;
    /**
     * See {@link DEngine.findNotes}
     */
    findNotes(opts: FindNoteOpts): Promise<NoteProps[]>;
    /**
     * See {@link DEngine.findNotesMeta}
     */
    findNotesMeta(opts: FindNoteOpts): Promise<NotePropsMeta[]>;
    bulkWriteNotes(opts: BulkWriteNotesOpts): Promise<import("@dendronhq/common-all").BulkResp<NoteChangeEntry[]>>;
    deleteNote(id: string, opts?: EngineDeleteOpts): ReturnType<DEngineClient["deleteNote"]>;
    deleteSchema(id: string, opts?: EngineDeleteOpts): Promise<DEngineDeleteSchemaResp>;
    getConfig(): Promise<{
        error: null;
        data: any;
    }>;
    getSchema(id: string): Promise<RespV2<SchemaModuleProps>>;
    info(): Promise<RespV2<EngineInfoResp>>;
    queryNotesSync({ qs, originalQS, }: {
        qs: string;
        originalQS: string;
    }): ReturnType<DEngineClient["queryNotesSync"]>;
    querySchema(queryString: string): Promise<SchemaQueryResp>;
    queryNotes(opts: QueryNotesOpts): Promise<NoteQueryResp>;
    renderNote({ id, note, flavor, dest, }: RenderNoteOpts): Promise<RespV2<RenderNotePayload>>;
    private isCachedPreviewUpToDate;
    private _renderNote;
    sync(): Promise<never>;
    refreshNotes(opts: RefreshNotesOpts): Promise<{
        error: null;
    }>;
    refreshNotesV2(notes: NoteChangeEntry[]): Promise<void>;
    renameNote(opts: RenameNoteOpts): Promise<RespV2<RenameNotePayload>>;
    /**
     * TODO: this should return a ERROR
     * See {@link FileStorageV2.updateNote}
     * @param note
     * @param opts
     * @returns
     */
    updateNote(note: NoteProps, opts?: EngineUpdateNodesOptsV2): Promise<import("@dendronhq/common-all").UpdateNoteResp>;
    updateIndex(mode: DNodeType): Promise<void>;
    updateSchema(schemaModule: SchemaModuleProps): Promise<void>;
    writeConfig(opts: ConfigWriteOpts): ReturnType<DEngine["writeConfig"]>;
    addAccessTokensToPodConfig(opts: {
        path: string;
        tokens: {
            accessToken: string;
            expirationTime: number;
            refreshToken?: string;
        };
    }): Promise<void>;
    writeNote(note: NoteProps, opts?: EngineWriteOptsV2): Promise<WriteNoteResp>;
    writeSchema(schema: SchemaModuleProps): Promise<void>;
    getNoteBlocks(opts: GetNoteBlocksOpts): Promise<GetNoteBlocksPayload>;
    getDecorations(opts: GetDecorationsOpts): Promise<GetDecorationsPayload>;
}
export declare const createEngine: ({ wsRoot }: WorkspaceOpts) => DEngineClient;
export {};
